#!/usr/bin/env ts-node
import fs from 'fs';
import path from 'path';
import { buildSchemaManifest } from './manifest';
import { buildManifestHash } from './mapping';
import { ManifestTable, SchemaManifest } from './types';

const BACKEND_ROOT = path.resolve(__dirname, '..', '..');
const GENERATED_DIR = path.join(BACKEND_ROOT, 'src', 'db', 'local', 'generated');
const GENERATED_SEEDS_DIR = path.join(GENERATED_DIR, 'seeds');
const SCHEMA_OUTPUT = path.join(GENERATED_DIR, 'schema.sql');
const MANIFEST_OUTPUT = path.join(GENERATED_DIR, 'schema-manifest.json');
const MANIFEST_HASH_OUTPUT = path.join(GENERATED_DIR, 'schema-manifest.hash');
const SEEDS_TEMPLATE = path.join(__dirname, 'templates', 'dev-seeds.sql');
const SEEDS_OUTPUT = path.join(GENERATED_SEEDS_DIR, 'dev.sql');
const SOURCE_DOC = path.join(BACKEND_ROOT, 'docs', 'DATABASE_SCHEMA_COMPLETE.md');

function ensureDirectories(): void {
  fs.mkdirSync(GENERATED_DIR, { recursive: true });
  fs.mkdirSync(GENERATED_SEEDS_DIR, { recursive: true });
}

function inferPrimaryKeys(table: ManifestTable): ManifestTable {
  if (!table.primaryKey) {
    const idColumn = table.columns.find((column) => column.name === 'id');
    if (idColumn) {
      idColumn.nullable = false;
      table.primaryKey = ['id'];
    }
  }
  return table;
}

function formatTableDefinition(table: ManifestTable): string {
  const columnLines = table.columns.map((column) => {
    const pieces = [quoteIdentifier(column.name), column.postgresType];
    if (!column.nullable) {
      pieces.push('NOT NULL');
    }
    const commentSuffix = formatColumnComment(column.comment);
    return `  ${pieces.join(' ')}${commentSuffix}`;
  });

  if (table.primaryKey && table.primaryKey.length > 0) {
    columnLines.push(`  PRIMARY KEY (${table.primaryKey.map(quoteIdentifier).join(', ')})`);
  }

  const definition = columnLines.join(',\n');
  const fullName = `${quoteIdentifier(table.schema)}.${quoteIdentifier(table.name)}`;
  const header = `-- Table: ${table.schema}.${table.name}${table.fullName ? ` (source: ${table.fullName})` : ''}`;
  return `${header}
CREATE TABLE IF NOT EXISTS ${fullName} (
${definition}
);
`;
}

function formatColumnComment(comment?: string): string {
  if (!comment) {
    return '';
  }
  const sanitized = comment.replace(/\*\//g, '* /').replace(/\r?\n/g, ' ').trim();
  if (!sanitized) {
    return '';
  }
  return ` /* ${sanitized} */`;
}

function quoteIdentifier(id: string): string {
  if (/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(id)) {
    return id;
  }
  return `"${id.replace(/"/g, '""')}"`;
}

export function renderSchema(manifest: SchemaManifest): string {
  const pieces: string[] = [];
  pieces.push('-- Auto-generated by scripts/dbx-manifest/generate.ts');
  pieces.push('-- Do not edit manually.');
  pieces.push('SET client_min_messages TO WARNING;');
  pieces.push('');

  for (const schema of manifest.schemas) {
    pieces.push(`CREATE SCHEMA IF NOT EXISTS ${quoteIdentifier(schema.name)};`);
  }

  pieces.push('');

  for (const schema of manifest.schemas) {
    pieces.push(`-- Schema: ${schema.name}`);
    for (const table of schema.tables) {
      const enrichedTable = inferPrimaryKeys(table);
      pieces.push(formatTableDefinition(enrichedTable));
    }
    pieces.push('');
  }

  return pieces.join('\n');
}

function writeOutputs(manifest: SchemaManifest, manifestHash: string, schemaSql: string): void {
  fs.writeFileSync(MANIFEST_OUTPUT, `${JSON.stringify(manifest, null, 2)}\n`, 'utf8');
  fs.writeFileSync(MANIFEST_HASH_OUTPUT, `${manifestHash}\n`, 'utf8');
  fs.writeFileSync(SCHEMA_OUTPUT, schemaSql, 'utf8');

  if (!fs.existsSync(SEEDS_TEMPLATE)) {
    console.warn('[dbx-manifest] Seed template not found; skipping seed generation');
  } else {
    fs.copyFileSync(SEEDS_TEMPLATE, SEEDS_OUTPUT);
  }
}

function logSummary(manifest: SchemaManifest, manifestHash: string): void {
  const schemaCount = manifest.schemas.length;
  const tableCount = manifest.schemas.reduce((acc, schema) => acc + schema.tables.length, 0);
  console.log(`[dbx-manifest] Generated manifest for ${tableCount} tables across ${schemaCount} schemas.`);
  console.log(`[dbx-manifest] Manifest hash: ${manifestHash}`);
  console.log(`[dbx-manifest] Schema written to ${path.relative(BACKEND_ROOT, SCHEMA_OUTPUT)}`);
  console.log(`[dbx-manifest] Seeds copied to ${path.relative(BACKEND_ROOT, SEEDS_OUTPUT)}`);
}

export function produceManifestArtifacts(): { manifest: SchemaManifest; manifestHash: string; schemaSql: string } {
  const manifest = buildSchemaManifest(SOURCE_DOC, { sourcePath: BACKEND_ROOT });
  const manifestHash = buildManifestHash(manifest);
  const schemaSql = renderSchema(manifest);
  return { manifest, manifestHash, schemaSql };
}

export function main(): void {
  ensureDirectories();
  const { manifest, manifestHash, schemaSql } = produceManifestArtifacts();
  writeOutputs(manifest, manifestHash, schemaSql);
  logSummary(manifest, manifestHash);
}

if (require.main === module) {
  main();
}
